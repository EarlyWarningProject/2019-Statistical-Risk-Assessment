---
title: "Data Review"
output: 
  pdf_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = FALSE)
library(readxl)
library(dplyr)
library(data.table)
library(knitr)
library(ggplot2)
library(ggpubr)
```


\newpage


#Introduction


- Section 1 compares the dataset that I recreated using data through 2017. Earlier versions of this document included differences between the dataset that were due to errors I made when re-writing the code. As all of these errors have now been resolved, these are no longer discussed. The remaining differences in the datasets are due to me fixing a variable that I believe was previously incorrect. 

- We have decided to append the 2018 data to the data through 2017 to avoid any unnecessary changes in the model. Section 2 ensures that nothing in the 2018 dataset has changed prior to 2017, except what is discussed.  

- Both Sections 1 and 2 first describe the data changes in words, and then show what was described in the overview through code. 

- Sections 3 is a spot check of all variables for a given country. I investigate any sudden jumps in variables and determine that everything looks fine. 

- Section 4 answers some specific questions

#Section 1: Initial Code Re-Write, Data through 2017

##Overview

Variables that are different between the original data and my recreated data:

- \textbf{wdi.imrate and imr.sqrt}: The original version of the data was created when the WDI had not yet released infant mortality rate data for 2016 and 2017. Because this is a slow-moving variable, its value was carried forward from 2015 for each country. As of June 2019, the WDI has not released infant mortality rate data for 2018, but has released it for 2016 and 2017. To avoid carrying forward the 2015 values, I updated the infant mortality rate date for 2016 and 2017. The variable imr.sqrt is created from wdi.imrate, so it varies in the same way. 
- \textbf{polity2 and polity2.sq}: These are different for Sudan in 2011. The polity dataset that we get from Monty has two entries in Sudan for 2011, one of which we want to delete. I either wrote it down wrong or the original code was mistaken. I need to confirm with CH which 2011 Sudan we mean to keep. 
- \textbf{battledeaths and battledeaths.ln}: The battledeaths variable has been changed to include incidents of types 3 and 4, and to represent the total number of battledeaths in a country each year. It previously took types 2, 3, and 4 from the UCDP data (after 2008), and types 3 from the PRIO data (up through 2008). I show in the code below that for the countries that only had one incident in a year, after 2008 (to avoid including type 4 incidents when the original did not), my variable is the same as the original.
- \textbf{anymk.start.1, anymk.start.2, anymk.start.2}: The differences between the any mass killing lead variables is only in the sum of missing values. This is due to an inconsistent policy regarding discontinued SFTG codes. For some instances in the previous data, if an SFTG code was no longer used after 1960, the one-year lead variable was set to NA in 1960, the two-year lead variable was set to NA in 1959, and the three-year lead variable was set to NA in 1960. In the most updated version of my data, I have made it so that discontinued SFTG codes inherit the lead values of their descendant countries. For example, Russia, which had SFTG code "USS" until 1991, and "RUS" thereafter, experienced a mass killing in 1994. Therefore, the observation with SFTG code "USS" in 1991 should have a 1 for the variable "anymk.start.3". 
- \textbf{anymk.start.2window and anymk.start.3window}: The changes in these variables result from the changes in the anymk.start lead variables discussed above. 
- \textbf{tradeshare.ln.combined}: I had noticed that the original code fills in missingness for some countries that aren't missing, writing over data. This could be because the original code was written before the latest pull from the WDI API. I have only filled in the missing values.  
- \textbf{wdi.gdppcgrow.new.adj}:This variable is the vector of predicted values from a regression of the V-Dem tradeshare variable on the WDI tradeshare variable. These two variables are identical between datasets, and I have not been able to find a reason why the predicted values should differ if the inputs do not. However, I confirm below that my variable is as it should be, and the two variables are nearly perfectly correlated. 
- \textbf{gdppcgrowth.combined}:This variable is made from the wdi.gdppcgrow.new.adj variable above, so it is expected to be different wherever that variable is different. I confirm in the code below that this is the case.



##Code

```{r, echo =TRUE, eval= TRUE}
load("prepared2017predictors_8_22_19.RData")
# save this to compare to original data later
my_dat <- dat

# original data is called dat
load("prepared2017predictors_15Oct2018.RData")

my_dat$wdi.imrate.new <- NULL
my_dat$last_year <- NULL
my_dat$ses_power_dist <- NULL

dat <- dat[, colnames(my_dat)]

compare <- merge(dat, my_dat, by = c("sftgcode", "year"))
# compare$anymk.start.1.x
# compare[is.na(compare$anymk.start.1.x), ]
ind <- matrix(3:ncol(compare), ncol = 2)

check <- lapply(1:nrow(ind), 
                function(x) all.equal(compare[, ind[x, 1]], compare[, ind[x, 2]]))

names(check) <- colnames(compare[, ind[, 1]])
cv <- unlist(check)
(mismatches <- names(cv[cv!="TRUE"]))
```

```{r, echo =TRUE, eval= TRUE}
# function to look at where the datasets are different for a specific variable, 
# omitting NAs which have been encoded differently for some reason
compare_var <- function(var){
  vars <- paste(var, c("x", "y"), sep = ".")
  look <- compare[compare[, vars[1]] != compare[, vars[2]], 
                c("year", "sftgcode", vars[1], vars[2])]
  na.omit(look)
}
```


###country_name

This difference is not concerning and is due simply to the level sets of the factors being different. Changing these variables to vectors of character strings shows that there is no difference. 

```{r, echo =TRUE, eval= TRUE}
check$country_name.x

# the differences are fixed by changing the class ofthe variable
c1 <- as.character(compare$country_name.x)
c2 <- as.character(compare$country_name.y)
all.equal(c1, c2)

# remove this variable from to-do list
mismatches <- mismatches[-which(grepl("country", mismatches))]
```

###minority rule

We changed the vdem variable used in previous years, so that minority rule reflects social groups, not ses groups.

###wdi.imrate and imr.sqrt

- Recall that we had decided to update infant mortality rate in 2016 and 2017 instead of just appending 2018 onto the original data. This was decided to avoid carrying forward a 2015 value through to 2018 (which is missing).
- To check that nothing else has changed, I compare the data prior to 2016, as this should be equal between datasets. They are equal, so this is resolved. 

```{r, echo =TRUE, eval= TRUE}
comp_sm <- compare[compare$year < 2016, ]
check_sm <- lapply(1:nrow(ind), 
                function(x) all.equal(comp_sm[, ind[x, 1]], comp_sm[, ind[x, 2]]))

names(check_sm) <- colnames(comp_sm[, ind[, 1]])
cv <- unlist(check_sm)
(mismatches_sm <- names(cv[cv!="TRUE"]))
# this takes care of wdi.imrate 

# I had fixed this following Mollie's pointing out that it shold have been a square root in previous versions
check <- compare_var("imr.sqrt")
check[check$year < 2016,]

# remove from to-do
mismatches <- mismatches[-which(grepl("imr", mismatches))]
```



###polity2 and polity2_sq

- In discussions with CH, we decided to keep the Sudan 2011 with the -4 value. 

```{r, echo =TRUE, eval= TRUE}
compare_var("polity2")
```


###battledeaths and battledeaths.ln

- There are two changes to the battle-deaths variable: first, only conflicts of type 3 and 4 are included, while conflicts of types 2, 3, and 4 were included in past years (after 2008, using UCDP data; prior to 2008, Prio data of type 3 was used). The second change is fixing an error in the construction of the battle-deaths variable, taking the total number of battle-deaths per country per year, instead of only the last incident for each country per year. 
- I can still compare these by comparing countries that only had one incident in a year, because these variables should be equal. I also can only look at observations after 2008, because before them the PRIO data excluded incidents of type 4, so there are 0s in the original data where there are none in the updated data. 

```{r, echo =TRUE, eval= TRUE}
compare_var("battledeaths") %>% head(20)

# lets double check that these are the same in countries that only had one incident in a year:
```

```{r, echo =TRUE, eval= TRUE}
ucdp = read_excel("data/2019/ucdp-brd-dyadic-191.xlsx")

# making sure we have the same variables as in 18.1 version. 
# colnames for 18.1 are uppercase, use tolower when checking
colnames(ucdp) <- gsub("_", "", colnames(ucdp))
# Side A ID not available in 18.1 version, delete it here
ucdp$sideaid <- NULL

ucdp = ucdp %>% filter(typeofconflict >= 3)

ucdp$locationinc = as.character(ucdp$locationinc)

# changes from 18.1
ucdp$locationinc[ucdp$locationinc=="Myanmar (Burma)"] = "Burma/Myanmar"
ucdp$locationinc[ucdp$locationinc=="Yemen (North Yemen)"] = "Yemen"
ucdp$locationinc[ucdp$locationinc=="DR Congo (Zaire)"] = "Democratic Republic of Congo"
ucdp$locationinc[ucdp$locationinc=="Russia (Soviet Union)"] = "Russia"
ucdp$locationinc[ucdp$locationinc=="Congo"] = "Republic of the Congo"
```

```{r, echo =TRUE, eval= TRUE}
conflict_count <- table(ucdp$year, ucdp$locationinc)
# head(conflict_count[, 1:5])
year_ind <- apply(conflict_count, 2, function(x) which(x == 1))
years_keep <- lapply(year_ind, names)

x <- years_keep[1]
try <- do.call("rbind", (lapply(1:length(years_keep), 
                                function(x) 
                                  compare[compare$country_name.x == 
                                            names(years_keep[x]) & 
                                            compare$year %in% 
                                            years_keep[x][[1]], 
                                          c("battledeaths.x", "battledeaths.y", 
                                            "country_name.x", "year")])))

# these are countries that only had one incident in a year
head(try, 10)

# filter to only include incidents after 2008, because we also updated the PRIO data
try_08 <- try[try$year > 2008, ]

# still not equal:
all.equal(try_08$battledeaths.x, try_08$battledeaths.y)

mismatches <- mismatches[-which(grepl("battledeaths", mismatches))]
```


###anymk lead variables

- The differences between the any mass killing lead variables is that the updated data has less NA's than the original data. 
- This is due to an inconsistent policy regarding discontinued SFTG codes. For some instances in the previous data, if an SFTG code was no longer used after 1960, the one-year lead variable was set to NA in 1960, the two-year lead variable was set to NA in 1959, and the three-year lead variable was set to NA in 1960. 
- In the most updated version of my data, I have made it so that discontinued SFTG codes inherit the lead values of their descendant countries. For example, Russia, which had SFTG code "USS" until 1991, and "RUS" thereafter, experienced a mass killing in 1994. Therefore, the observation with SFTG code "USS" in 1991 should have a 1 for the variable "anymk.start.3". 
- Below is a list of countries that this affects. 

```{r}
load("prepared2017predictors_8_22_19.RData")
end <- unique(dat[dat$last_year != 2017, c("country_name", "last_year", "sftgcode")])


new_sftg <- sapply(end$country_name, function(x) 
  dat$sftgcode[dat$country_name == x & dat$year  == 2017])

new_sftg <- lapply(new_sftg, as.character)

end$new_sftg <- new_sftg
kable(end)
# dat$country_name[dat$year == 2017] %>% unique
# dat$sftgcode[dat$country_name == "Yemen"]
# 
# dat$country_name[dat$sftgcode == "VIE"]
```

```{r, echo =TRUE, eval= TRUE}
anymk_vars <- gsub(".x", "", grep("anymk", mismatches, value = TRUE))

(all_anymk <- lapply(anymk_vars, compare_var))
# the only differences are in the NA's
 

# My data has less NA than the original data
# sum(is.na(compare$anymk.start.2.y)) - sum(is.na(compare$anymk.start.2.x))
# sum(is.na(compare$anymk.start.3.y)) - sum(is.na(compare$anymk.start.3.x))
# sum(is.na(compare$anymk.start.2window.y)) - sum(is.na(compare$anymk.start.2window.x))
# sum(is.na(compare$anymk.start.3window.y)) - sum(is.na(compare$anymk.start.3window.x))

```




####anymk.start.2
```{r}
check.x <- compare[is.na(compare$anymk.start.2.x), c("sftgcode", "year")]
check.x$data <- "x"
check.y <- compare[is.na(compare$anymk.start.2.y), c("sftgcode", "year")]
check.y$data <- "y"

look <- merge(check.x, check.y, by = c("sftgcode", "year"), all.x = TRUE)
(na_mismatch <- look[is.na(look$data.y), c("sftgcode", "year")])
# this shows what is NA in the original data that is not NA in the new data
# new policy of discontinued sftgcodes inheriting their values from the descending countries

na_mismatch$max_year <- sapply(na_mismatch$sftgcode, 
                               function(x) max(dat$year[dat$sftgcode == x]))
na_mismatch
```

####anymk.start.3
```{r}
check.x <- compare[is.na(compare$anymk.start.3.x), c("sftgcode", "year")]
check.x$data <- "x"
check.y <- compare[is.na(compare$anymk.start.3.y), c("sftgcode", "year")]
check.y$data <- "y"

look <- merge(check.x, check.y, by = c("sftgcode", "year"), all.x = TRUE)
na_mismatch <- look[is.na(look$data.y), c("sftgcode", "year")]



na_mismatch$max_year <- sapply(na_mismatch$sftgcode, 
                               function(x) max(dat$year[dat$sftgcode == x]))
na_mismatch

# Similarly the years for which I have NA's and the original data does not are the years where you could not have a lead on the variable because it was within a 3-year window of the last year that the sftgcode was in use. 
```

####anymk.start.2window
```{r}
# check 2 year window
check.x <- compare[is.na(compare$anymk.start.2window.x), c("sftgcode", "year")]
check.x$data <- "x"
check.y <- compare[is.na(compare$anymk.start.2window.y), c("sftgcode", "year")]
check.y$data <- "y"

look <- merge(check.x, check.y, by = c("sftgcode", "year"), all.x = TRUE)
na_mismatch <- look[is.na(look$data.y), c("sftgcode", "year")]

na_mismatch$max_year <- sapply(na_mismatch$sftgcode, 
                               function(x) max(dat$year[dat$sftgcode == x]))

na_mismatch
```

####anymk.start.3window
```{r}
# check 3 year window
check.x <- compare[is.na(compare$anymk.start.3window.x), c("sftgcode", "year")]
check.x$data <- "x"
check.y <- compare[is.na(compare$anymk.start.3window.y), c("sftgcode", "year")]
check.y$data <- "y"

look <- merge(check.x, check.y, by = c("sftgcode", "year"), all.x = TRUE)
na_mismatch <- look[is.na(look$data.y), c("sftgcode", "year")]

na_mismatch$max_year <- sapply(na_mismatch$sftgcode, 
                               function(x) max(dat$year[dat$sftgcode == x]))

na_mismatch
```



```{r}
# check off to-do
(mismatches <- mismatches[-which(grepl("anymk", mismatches))])
```




###tradeshare combined


```{r}
look <- compare_var("tradeshare.ln.combined")


# recall that tradeshare.ln.combined is a variable consisting of log(tradeshare) (from V-Dem), and where that is missing, it is supplemented with the predicted value from a regression of V-Dem tradeshare on WDI tradeshare. Therefore these should only be different where there were NAs for V-Dem tradeshare  

na_comb <- my_dat[which(is.na(my_dat$tradeshare)), c("sftgcode", "year")]
na_comb <- paste0(na_comb$sftgcode, na_comb$year) 

diff <- paste0(look$sftgcode, look$year)
setdiff(diff, na_comb)

compare[compare$tradeshare.ln.combined.x != compare$tradeshare.ln.combined.y,
        c("tradeshare.ln.x", "wdi.trade.ln.new.adj.x","year", "country_name.x", 
          "tradeshare.ln.combined.x", "tradeshare.ln.combined.y")] %>% na.omit
# these seem to be the same

round(compare$tradeshare.ln.combined.x[compare$sftgcode=="BFO" & compare$year == 1983], 15)==round(compare$tradeshare.ln.combined.y[compare$sftgcode=="BFO" & compare$year == 1983], 15)

round(compare$tradeshare.ln.combined.x[compare$sftgcode=="BFO" & compare$year == 1983], 16)==round(compare$tradeshare.ln.combined.y[compare$sftgcode=="BFO" & compare$year == 1983], 16)
# they are equal at tolerance level 1e-15

(mismatches <- mismatches[-which(grepl("tradeshare", mismatches))])


cor(compare$tradeshare.ln.combined.x, 
    compare$tradeshare.ln.combined.y, use = "complete.obs")


```



###GDP per capita growth

```{r}
# gdppcgrowth.combined is made from wdi.gdppcgrow.new.adj, 
# so it should differ wherever the latter differs. 
check <- compare_var("gdppcgrowth.combined")
check2 <- compare_var("wdi.gdppcgrow.new.adj")

check_comb <- paste0(check$sftgcode, check$year)
check2_comb <- paste0(check2$sftgcode, check2$year)

setdiff(check_comb, check2_comb)
# so this variable is fine.

# lets investigate the adjusted variable and see why that changes
# it should only change if there is a difference in wdi.gdppcgrow.new or 
# gdppcgrowth between datasets which there isn't. 

all.equal(compare$wdi.gdppc.new.x, compare$wdi.gdppc.new.y)
all.equal(compare$gdppcgrowth.x, compare$gdppcgrowth.y)

reg1 <- lm(gdppcgrowth.x~wdi.gdppcgrow.new.x, data = compare)
reg2 <- lm(gdppcgrowth.y~wdi.gdppcgrow.new.y, data = compare)

all.equal(cbind(reg1$coefficients, reg2$coefficients)[1, 1], 
          cbind(reg1$coefficients, reg2$coefficients)[1, 2])
all.equal(cbind(reg1$coefficients, reg2$coefficients)[2, 1], 
          cbind(reg1$coefficients, reg2$coefficients)[2, 2])

compare$wdi.gdppcgrow.check <- reg1$coefficients[1] + 
  reg2$coefficients[2]*compare$wdi.gdppcgrow.new.x

all.equal(compare$wdi.gdppcgrow.check, compare$wdi.gdppcgrow.new.adj.x)
all.equal(compare$wdi.gdppcgrow.check, compare$wdi.gdppcgrow.new.adj.y)
# y version seems to be correct, but regardless, it's not a big change: 

cor(compare$wdi.gdppcgrow.new.adj.x, 
    compare$wdi.gdppcgrow.new.adj.y, use = "complete.obs")

ggplot(compare) + 
  geom_point(aes(x = wdi.gdppcgrow.new.adj.x, y = wdi.gdppcgrow.new.adj.y)) +
  geom_abline(intercept = 0, slope = 1, color = "red")

(mismatches <- mismatches[-which(grepl("gdp", mismatches))])
```





#Section 2: Append Check

##Overview

In this section, I compare my updated data, which should just be the 2018 data appended to my re-written version of the data through 2017, with my rewritten data through 2017. The purpose of this exercise is to ensure that I succeeded in appending the data without changing anything else prior to 2018. Comparisons are between my updated data, excluding 2018, and my recreated version of the 2017 data. Variables that are different between datasets:

- \textbf{mkl.end and mkl.ongoing}: These variables change because the Sudan event was back-coded to end in 2016. Therefore, mkl.end is now a 1 for Sudan in 2016, where it was previously a 0. Similarly, mkl.ongoing is not a 0 in 2017 where it was previously a 1. 
- \textbf{anymk.start.1, anymk.start.2, anymk.start.2}: These variables are different because lead variables that were previously NA are now 0. This is because we have an extra year of data, so we can actually fill out those lead variable. I show in the code below that the only difference is a constant shift in the number of missing observations. 
- \textbf{anymk.start.2window and anymk.start.3window}: The changes in these variables result from the changes in the anymk.start lead variables discussed above. 
- \textbf{last.year}:This variable was created by me to update the lead variables only through the applicable window. It should change 1 year for each year that a country is not dissolved. 


##Code

```{r, echo =TRUE, eval= TRUE}
load("prepared2018predictors_9_19_19.RData")
# save this to compare to original data later
check_dat <- dat[dat$year <= 2017, ]

# original data is called dat
load("prepared2017predictors_8_22_19.RData")

# setdiff(colnames(check_dat), colnames(dat))
dat <- dat[, colnames(check_dat)]

compare <- merge(dat, check_dat, by = c("sftgcode", "year"))
ind <- matrix(3:ncol(compare), ncol = 2)

check <- lapply(1:nrow(ind), 
                function(x) all.equal(compare[, ind[x, 1]], compare[, ind[x, 2]]))

names(check) <- colnames(compare[, ind[, 1]])
cv <- unlist(check)
(mismatches <- names(cv[cv!="TRUE"]))
```


### mkl.end and mkl.ongoing

- We should expect to see changes in this variable due to the back-coded ending of the Sudan event in 2016. I show below that this is the only change:

```{r, echo =TRUE, eval= TRUE}
compare_var("mkl.end")
compare_var("mkl.ongoing")

# update to-do
mismatches <- mismatches[-which(grepl("mkl.", mismatches))]
```

###Any Mass Killing Lead variables

The only change in this variable should be a difference in the number of NAs. We have an extra year of data, so the difference in NA counts should be the number of countries that we observe each year, 163. I also verify below that the only year that is no longer NA in the updated data for the 1-year (2-year, 3-year) lead is 2017 (2016, 2015). 

```{r}
anymk_vars <- gsub(".x", "", grep("anymk", mismatches, value = TRUE))

lapply(anymk_vars, compare_var)
# the only change should be from NA to 0, as we have one more year of information. It should only be different for 2017 for 1 year lead, 2016 for 2 year lead, and 2015 for 3 year lead

sum(is.na(compare$anymk.start.1.x)) - sum(is.na(compare$anymk.start.1.y))
sum(is.na(compare$anymk.start.2.x)) - sum(is.na(compare$anymk.start.2.y))
sum(is.na(compare$anymk.start.3.x)) - sum(is.na(compare$anymk.start.3.y))
sum(is.na(compare$anymk.start.2window.x)) - sum(is.na(compare$anymk.start.2window.y))
sum(is.na(compare$anymk.start.3window.x)) - sum(is.na(compare$anymk.start.3window.y))
```

####anymk.start.1
```{r}
# check 1 year lead
check.x <- compare[is.na(compare$anymk.start.1.x), c("sftgcode", "year")]
check.x$data <- "x"
check.y <- compare[is.na(compare$anymk.start.1.y), c("sftgcode", "year")]
check.y$data <- "y"

look <- merge(check.x, check.y, by = c("sftgcode", "year"), all.x = TRUE)
na_mismatch <- look[is.na(look$data.y), c("sftgcode", "year")]
na_mismatch$year %>% table
```


####anymk.start.2
```{r}
# check 2 year lead
check.x <- compare[is.na(compare$anymk.start.2.x), c("sftgcode", "year")]
check.x$data <- "x"
check.y <- compare[is.na(compare$anymk.start.2.y), c("sftgcode", "year")]
check.y$data <- "y"

look <- merge(check.x, check.y, by = c("sftgcode", "year"), all.x = TRUE)
na_mismatch <- look[is.na(look$data.y), c("sftgcode", "year")]
na_mismatch$year %>% table
```


####anymk.start.3
```{r}
# check 3 year lead
check.x <- compare[is.na(compare$anymk.start.3.x), c("sftgcode", "year")]
check.x$data <- "x"
check.y <- compare[is.na(compare$anymk.start.3.y), c("sftgcode", "year")]
check.y$data <- "y"

look <- merge(check.x, check.y, by = c("sftgcode", "year"), all.x = TRUE)
na_mismatch <- look[is.na(look$data.y), c("sftgcode", "year")]
na_mismatch$year %>% table


```

####anymk.start.2window
```{r}
# check 2 window
check.x <- compare[is.na(compare$anymk.start.2window.x), c("sftgcode", "year")]
check.x$data <- "x"
check.y <- compare[is.na(compare$anymk.start.2window.y), c("sftgcode", "year")]
check.y$data <- "y"

look <- merge(check.x, check.y, by = c("sftgcode", "year"), all.x = TRUE)
na_mismatch <- look[is.na(look$data.y), c("sftgcode", "year")]

na_mismatch$max_year <- sapply(na_mismatch$sftgcode, 
                               function(x) max(dat$year[dat$sftgcode == x]))
# the differences are all less than 2, so they should be NA
na_mismatch$max_year - na_mismatch$year
```


####anymk.start.3window
```{r}
# check 3 window
check.x <- compare[is.na(compare$anymk.start.3window.x), c("sftgcode", "year")]
check.x$data <- "x"
check.y <- compare[is.na(compare$anymk.start.3window.y), c("sftgcode", "year")]
check.y$data <- "y"

look <- merge(check.x, check.y, by = c("sftgcode", "year"), all.x = TRUE)
na_mismatch <- look[is.na(look$data.y), c("sftgcode", "year")]

na_mismatch$max_year <- sapply(na_mismatch$sftgcode, 
                               function(x) max(dat$year[dat$sftgcode == x]))
# the differences are all less than 3, so they should be NA
na_mismatch$max_year - na_mismatch$year
```

```{r}
# remove from to-do
(mismatches <- mismatches[-which(grepl("anymk", mismatches))])
```


###last_year

This is a variable I created that is the last year a country is observed in the data. This should increase by 1 for the countries that were not dissolved prior to 2017. 

```{r}
compare_var("last_year")[, c("last_year.x", "last_year.y")] %>% unique
```


#Section 3: Spot Check of All Variables

This section provides code to check each variable for a given country. I have investigated all variables for 4 countries (CON, ZAI, EGY, SUD) and have verified anything that looks strange. Where there are sudden jumps in V-Dem variables, it is often due to our policy of appending the data. The printed output is currently for Egypt.

```{r}

outcomenames <- c("anymk.start.1", "anymk.start.2window")


predictornames <- c("anymk.ongoing","anymk.ever",
                    "reg.afr", "reg.eap", "reg.eur", "reg.mna", "reg.sca", 
                    "countryage.ln", "popsize.ln.combined", "imr.sqrt", 
                    "gdppcgrowth.combined", "ios.iccpr1","includesnonstate",
                    "durable.ln","minorityrule", "elf.ethnic", "battledeaths.ln",
                    "candidaterestriction", "partyban","judicialreform",
                    "religiousfreedom", "pol_killing_approved",
                    "freemove_men4","freemove_women4", "freediscussion",
                    "social_inequality","even_civilrights","repress_civilsoc",
                    "social_power_dist","tradeshare.ln.combined", "coup.try.5yr", 
                    "cou.any",
                    "polity2.fl.2","polity2.fl.3")


```


```{r}
plot_check <- function(var, country_dat = sud){
  ggplot(country_dat) + geom_point(aes(x = year, y = country_dat[, var]))+ 
    labs(y = as.character(var))
}
```

```{r}
load("data/2018/vdem_keep.Rdata")
vdem18 <- vdem
load("data/2019/vdem_keep.Rdata")
vdem19 <- vdem


check_vdem <- function(sftg, var, vdem = vdem19){
  subset(vdem[sftgcode == sftg & year %in% c(2014:2018)], select = c(var, "year"))
}


```



```{r}
load("prepared2018predictors_7_28_19.RData")

# make several country datasets to check
sud <- dat[dat$sftgcode == "SUD", ] 
egy <- dat[dat$sftgcode == "EGY", ]
drc <- dat[dat$sftgcode == "ZAI", ]
rc <- dat[dat$sftgcode == "CON", ]
```


##Check Outcomes
```{r}

# checks <- lapply(outcomenames, function(x) plot_check(x, country_dat = sud))
checks <- lapply(outcomenames, function(x) plot_check(x, country_dat = egy))
# checks <- lapply(outcomenames, function(x) plot_check(x, country_dat = drc))
# checks <- lapply(outcomenames, function(x) plot_check(x, country_dat = rc))
                 
ggarrange(checks[[1]], checks[[2]], nrow= 2)
```


##Check Predictors

```{r}
# checks <- lapply(predictornames, function(x) plot_check(x, country_dat = sud))
checks <- lapply(predictornames, function(x) plot_check(x, country_dat = egy))
# checks <- lapply(predictornames, function(x) plot_check(x, country_dat = rc))
names(checks) <- predictornames
```

```{r}
# anymk.ever and anymk.ongoing
ggarrange(checks[[1]], checks[[2]], nrow = 2)
```
\newpage

```{r}
# regions
ggarrange(checks[[3]], checks[[4]], checks[[5]], checks[[6]], checks[[7]])
```
\newpage

```{r}
ggarrange(checks[[8]],checks[[9]],checks[[10]],checks[[11]])
```

```{r}
ggarrange(checks[[12]], checks[[13]], checks[[14]], checks[[15]])

# (look <- check_vdem(sftg = "SUD", vdem = vdem19, var = "minorityrule"))
# (look <- check_vdem(sftg = "EGY", vdem = vdem19, var = "minorityrule"))
# (look <- check_vdem(sftg = "ZAI", vdem = vdem19, var = "minorityrule"))
(look <- check_vdem(sftg = "CON", vdem = vdem19, var = "minorityrule"))
```

\newpage

```{r}
checks[[16]]
```

\newpage

```{r}
# battledeaths
checks[[17]]

egy[order(egy$year, decreasing = TRUE), c("battledeaths", "year")] %>% head(10)
# drc[order(drc$year, decreasing = TRUE), c("battledeaths", "year")] %>% head(10)
# rc[order(rc$year, decreasing = TRUE), c("battledeaths", "year")] %>% head(10)
```

\newpage

```{r}
ggarrange(checks[[18]], checks[[19]], nrow = 2)
```

\newpage


```{r}
# judicial reform
checks[[20]]
# (look <- check_vdem(sftg = "SUD", var = "judicialreform"))
# (look <- check_vdem(sftg = "EGY", var = "judicialreform"))
# (look <- check_vdem(sftg = "ZAI", var = "judicialreform"))
(look <- check_vdem(sftg = "CON", var = "judicialreform"))
```

\newpage

```{r}
# religious freedom
checks[[21]]
# (look <- check_vdem(sftg = "ZAI", var = "religiousfreedom"))
(look <- check_vdem(sftg = "CON", var = "religiousfreedom"))
```

\newpage

```{r}
# pol_killing_approved
checks[[22]]

# (look <- check_vdem(sftg = "SUD", var = "pol_killing_approved"))

# (look <- check_vdem(sftg = "ZAI", var = "pol_killing_approved", vdem = vdem19))
# (look <- check_vdem(sftg = "ZAI", var = "pol_killing_approved", vdem = vdem18))

# (look <- check_vdem(sftg = "CON", var = "pol_killing_approved", vdem = vdem19))
# (look <- check_vdem(sftg = "CON", var = "pol_killing_approved", vdem = vdem18))

(look <- check_vdem(sftg = "EGY", var = "pol_killing_approved", vdem = vdem19))
(look <- check_vdem(sftg = "EGY", var = "pol_killing_approved", vdem = vdem18))
```

\newpage


```{r}
# freemove_women, freemove_men
ggarrange(checks[[23]], checks[[24]], nrow = 2)
```

\newpage

```{r}
# free discussion
ggarrange(checks[[25]], checks[[26]], nrow = 2)
# check_vdem(sftg = "SUD", var = "freediscussion" )
# check_vdem(sftg = "ZAI", var = "freediscussion" )
# check_vdem(sftg = "CON", var = "freediscussion" )
check_vdem(sftg = "EGY", var = "freediscussion" )
```

\newpage
```{r}
ggarrange(checks[[27]], checks[[28]], checks[[29]], checks[[30]])


# check_vdem(sftg = "EGY", var = "even_civilrights", vdem = vdem18)
# check_vdem(sftg = "EGY", var = "even_civilrights", vdem = vdem19)
# 2018 V-dem data has 1s where 2019 V-dem data does not for Egypt

```

\newpage

```{r}

# coup.try.5yr
ggarrange(checks[[31]], checks[[32]], nrow = 2)

# egy[order(egy$year, decreasing = TRUE), ] %>% 
#   select(c("year", "cou.any", "coup.try.5yr")) %>% head(10)
# drc[order(drc$year, decreasing = TRUE), ] %>% 
#   select(c("year", "cou.any", "coup.try.5yr")) %>% head(10)

```

\newpage

```{r}
# polity2
ggarrange(checks[[33]], checks[[34]], nrow = 2)
```


#Section 4: Specific questions

##Conflicting data from V-Dem

"The 2018 version of the data for 2017 is not the same as the 2019 version of the data for 2017."

What I meant by this is that V-Dem seems to have changed data for 2017 in their 2019 release of the dataset. Below I show the differences between V-Dem 2018 and V-Dem 2019 for their minority rule variable in 2017. 

```{r, echo = FALSE}
load("data/2018/vdem_keep.Rdata")
vdem18 <- vdem[vdem$year  == 2017, c("minorityrule", "country_name", "year")]
load("data/2019/vdem_keep.Rdata")
vdem19 <- vdem[vdem$year >= 2017, c("minorityrule", "country_name", "year")]

compare <- merge(vdem18, vdem19, by = c("country_name", "year"))
kable(compare[compare$minorityrule.x != compare$minorityrule.y], col.names = c("Country", "year", "V-dem 2018 minority rule", "V-dem 2019 minority rule"))
```

You will notice that Egypt is not listed above. This is because V-Dem actually does document a change in this variable. Below I present the un-altered V-Dem data from 2019. The minority rule variable comes from v2pepwrses_ord; it is 1 if v2pepwrses_ord is less than or equal to 1, and 0 otherwise. This is why we see the shift from 1 in 2017 to 0 in 2018 for Egypt.  

```{r, cache = TRUE, echo = FALSE}
vdem <- fread("data/2019/vdem/V-Dem-CY-Full+Others-v9.csv")
vdem <- subset(vdem, select = c("year", "country_name", "v2pepwrses_ord"))
```

```{r, echo = FALSE}
vdem[country_name == "Egypt" & year %in% c(2017, 2018)]

dat$minorityrule = 0
dat$minorityrule[dat$v2pepwrses_ord<=1]=1

```

##Retrospective Coding Changes

Below are the cases where V-Dem 2019 disagrees with V-Dem 2018 on 2017 data. Of the 23 variables we take from V-Dem, this occurs in 12 of them, listed below. 


```{r, echo =  FALSE}
load("data/2018/vdem_keep.Rdata")
vdem18 <- vdem[vdem$year  == 2017, ]

load("data/2019/vdem_keep.Rdata")
vdem19 <- vdem[vdem$year == 2017, ]

compare_vdem <- function(var){
  compare <- merge(subset(vdem18, select = c("country_name", "year", var)), 
                   subset(vdem19, select = c("country_name", "year", var)), 
                   by = c("country_name", "year"))
  diff <- compare[which(compare[, 3] != compare[, 4]), ]
  diff
}



look <- lapply(4:27, function(x) compare_vdem(var = colnames(vdem18)[x]))
names(look) <- colnames(vdem18)[4:27]
look <- look[which(lapply(look, nrow)>0)]



lapply(1:length(look), function(x) 
  kable(look[[x]], 
        caption = paste(names(look[x]), "V-Dem 2018 (x) v. V-Dem 2019 (y)")))
```




